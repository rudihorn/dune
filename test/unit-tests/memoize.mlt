open Dune;;
open Stdune;;
open Fiber.O;;
open Memoization;;
open Memoization.Memoize;;

Fiber.return 5;;
[%%expect{|
- : int Fiber.t = <abstr>
|}]

(* to run a computation *)
let runstr f v = f v |> Fiber.run;;

(* the trivial dependencies are simply the identity function *)
let compdep x = Fiber.return (x ^ x);;

let memcache = create_cache ();;

(* our two dependencies are called some and another *)
let mcompdep1 = memoization memcache "some" string_input_spec string_output_spec compdep;;
let mcompdep2 = memoization memcache "another" string_input_spec string_output_spec compdep;;

(* compute the dependencies once so they are present in the
   global hash table *)
runstr mcompdep1 "a";;
runstr mcompdep2 "a";;

[%%expect{|
val runstr : ('a -> 'b Fiber.t) -> 'a -> 'b = <fun>
val compdep : string -> string Fiber.t = <fun>
val memcache : '_weak1 t = <abstr>
val mcompdep1 : string -> string Fiber.t = <fun>
val mcompdep2 : string -> string Fiber.t = <fun>
- : string = "aa"
- : string = "aa"
|}]

(* define a counter so we can track how often our computation
   has been run *)
let counter = ref 0;;

(* our computation increases the counter, adds the two
   dependencies, "some" and "another" and works by multiplying
   the input by two *)
let comp x = 
  Fiber.return x >>=
  mcompdep1 >>=
  mcompdep2 >>=
  (fun a -> counter := !counter + 1; String.sub a 0 (String.length a |> min 3) |> Fiber.return);;

let mcomp = memoization memcache "test" string_input_spec string_output_spec comp;;

[%%expect{|
val counter : int ref = {contents = 0}
val comp : string -> string Fiber.t = <fun>
val mcomp : string -> string Fiber.t = <fun>
|}]

(* running it the first time should increase the counter,
   running it again should not, but should still return the
   same result *)
!counter;;
runstr mcomp "a";; 
!counter;;
runstr mcomp "a";; 
!counter;;

[%%expect{|
- : int = 0
- : string = "aaa"
- : int = 1
- : string = "aaa"
- : int = 1
|}]

get_deps "test" "a";;

[%%expect{|
- : (string * string) list option = Some [("another", "aa"); ("some", "a")]
|}]

(* running it on a new input should cause it to recompute
   the first time it is run *)
runstr mcomp "hello";; 
!counter;;
runstr mcomp "hello";; 
!counter;;

[%%expect{|
- : string = "hel"
- : int = 2
- : string = "hel"
- : int = 2
|}]

(* updating the first dependency should require recomputation of mcomp 7 *)
runstr mcompdep1 "testtest";;
runstr mcomp "hello";;
!counter;;
runstr mcomp "hello";;
!counter;;

[%%expect{|
- : string = "testtesttesttest"
- : string = "hel"
- : int = 2
- : string = "hel"
- : int = 2
|}]

let ismemcached = create_cache ();;

let stack = ref [];;
let dump_stack v =
  get_call_stack >>| (fun s -> stack := s; v);;

let mcompcycle =
  let mcompcycle = CRef.deferred () in
  let compcycle x = 
    Fiber.return x
    >>= dump_stack
    >>= (fun x ->
          counter := !counter + 1;
          if !counter < 20 then
            ((x + 1) mod 3) |> CRef.get mcompcycle
          else
            Fiber.never
        ) in
  memoization ismemcached "cycle" int_input_spec string_output_spec compcycle |> CRef.set mcompcycle;
  CRef.get mcompcycle;;

[%%expect{|
val ismemcached : '_weak2 t = <abstr>
val stack : '_weak3 list ref = {contents = []}
val dump_stack : 'a -> 'a Fiber.t = <fun>
val mcompcycle : (int, string) CRef.t = <fun>
|}]

counter := 0;
mcompcycle 5 |> Fiber.run;;
!counter;;
!stack;;

[%%expect{|
Exception: Never.
Raised at file "src/fiber/fiber.ml", line 428, characters 20-25
Called from file "toplevel/toploop.ml", line 180, characters 17-56
- : int = 4
- : (string * string) list =
[("cycle", "2"); ("cycle", "1"); ("cycle", "0"); ("cycle", "5")]
|}]

let iimemcached = create_cache ();;

let mfib = 
  let mfib = CRef.deferred () in
  let compfib x =
    let mfib = CRef.get mfib in
    counter := !counter + 1;
    if x <= 1 then
      Fiber.return x
    else
      mfib (x - 1)
      >>= (fun r1 ->
        mfib (x - 2)
        >>| fun r2 -> r1 + r2) in
  memoization iimemcached "fib" int_input_spec int_output_spec compfib |> CRef.set mfib;
  CRef.get mfib;;

counter := 0;
mfib 2000 |> Fiber.run;;
!counter;;

[%%expect{|
val iimemcached : '_weak4 t = <abstr>
val mfib : (int, int) CRef.t = <fun>
- : int = 2406280077793834213
- : int = 2001
|}]
